module Procedure.Promise exposing
    ( Promise
    , succeed
    , map
    , andAsync
    , andRace
    , layerEvent
    , portRequest
    , customRequest
    )

{-|

@docs Promise
@docs succeed
@docs map
@docs andAsync
@docs andRace
@docs layerEvent
@docs portRequest
@docs customRequest

-}

import Internal.Core as Core exposing
    (Promise(..)
    , PromiseResult(..)
    , Msg(..)
    )
import Internal.RequestId exposing (RequestId)
import Json.Decode exposing (Decoder)
import Json.Encode exposing (Value)


{-| The Promise represents the eventual completion of an operation and its resulting value. Similar to [Promise in JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).

-}
type alias Promise cmd memory event result =
    Core.Promise cmd memory event result


{-| Build a Promise that is always resolved with the given value.

This is usefull for building Promise for concurrent operations with `andAsync`.
-}
succeed : a -> Promise cmd memory event a
succeed = Core.succeedPromise


{-| Transform a Promise.
-}
map : (a -> b) -> Promise c m e a -> Promise c m e b
map = Core.mapPromise


{-| Run another Promise concurrently to get both results.

The following example build a Promise that requests A and B concurrently, awaits both result, and is resolved with sum of the results.

    succeed (\a b -> a + b)
        |> andAsync requestA
        |> andAsync requestB

-}
andAsync : Promise c m e a -> Promise c m e (a -> b) -> Promise c m e b
andAsync = Core.andAsyncPromise


{-| Run another Promise concurrently to get the firtst result.

May you want to set timeout on your request:

    requestWithTimeout =
        myRequest
            |> map Ok
            |> andRace
                ( sleep 10000
                    |> map Err
                )

-}
andRace : Promise c m e a -> Promise c m e a -> Promise c m e a
andRace = Core.andRacePromise


{-|
-}
layerEvent : (event -> Maybe a) -> Promise c m event a
layerEvent f =
    Promise <|
        \context ->
            let
                (Core.LayerChannel thisChannel) = context.layerChannel
            in
            { newContext = context
            , cmds = []
            , handler = \_ msg ->
                case msg of
                    ChannelMsg r ->
                        if (r.channel /= thisChannel) then
                            AwaitAgain <| layerEvent f
                        else
                            case f r.event of
                                Nothing ->
                                    AwaitAgain <| layerEvent f
                                Just a ->
                                    Resolved a
                    _ ->
                        AwaitAgain <| layerEvent f
            }



{-| Build a Promise to send one outgoing port Message and receive the corresponding incoming port Message only once.

For example, we can use `portRequest` to get localStorage value safely.

In JavaScript side:

```js
app.ports.requestGetLocalName.subscribe((req) => {
  try {
    app.ports.receiveGetLocalName.send({
      // The `requestId` value, generated by TEPA, links
      // the subscribe port to the relevant send port.
      requestId: req.requestId,
      body: {
        name: localStorage.getItem(`Name.${req.body.userId}`),
      },
    });
  } catch {
    app.ports.receiveGetLocalName.send({
      requestId: req.id,
      body: {
        name: null,
      },
    });
  }
});
```

In Elm side:

```elm
import Json.Encode as JE exposing (Value)
import Json.Decode as JD

port requestGetLocalName : Value -> Cmd msg
port receiveGetLocalName : (Value -> msg) -> Sub msg

type alias LocalNameResponse =
    { name : Maybe String
    }

requestLocalName : String -> Promise Command Memory Event LocalNameResponse
requestLocalName userId =
    portRequest
        { name = "Request for localStorage value"
        , request = \m { requestId } ->
            requestGetLocalName <| JE.object
                [ ( "requestId", requestId )
                , ( "body"
                  , JE.object
                    [ ( "userId"
                      , JE.string userId
                      )
                    ]
                  )
                ]
        , receiver = receiveGetLocalName
        , resposne = \requestId ->
            JD.map2 (\rid body -> (rid, body))
                (JD.field "requestId" requestId)
                (JD.field "body"
                    (JD.map LocalNameResponse
                        (JD.field "name"
                            (JD.nullable JD.string)
                        )
                    )
                )
        }
```


-}
portRequest :
    { name : String
    , request : m -> { requestId : Value } -> c
    , receiver : (Value -> Msg e) -> Sub (Msg e)
    , response : Decoder RequestId -> Decoder (RequestId, resp)
    }
    -> Promise c m e resp
portRequest = Core.portRequest


{-|
-}
customRequest :
    { name : String
    , request : m -> RequestId -> (e -> Msg e) -> c
    }
    -> Promise c m e e
customRequest = Core.customRequest
